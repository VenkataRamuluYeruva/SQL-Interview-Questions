# Tow Factor Authentication(2FA) with speakeasy in Node.js

### **Speakeasy Middleware: A Detailed Overview**

**Speakeasy** is a Node.js library that helps implement Two-Factor Authentication (2FA) using Time-based One-Time Passwords (TOTP). TOTP is the widely-used algorithm behind many 2FA systems (e.g., Google Authenticator, Authy, etc.). This method adds an extra layer of security to an application by requiring users to provide not only their password but also a temporary code generated on their mobile devices.

In a production-level or senior software environment, middleware refers to the functions or services that sit between the raw HTTP request and your applicationâ€™s core logic. The `speakeasy` library can be used to create such middleware to handle the generation and verification of TOTP codes in your authentication system.

Let's break down how to integrate **Speakeasy** as middleware in a production-level application with detailed code examples.

---

### **Key Concepts of Speakeasy**

1. **TOTP (Time-based One-Time Password)**:
   - It generates a unique password based on the current time and a shared secret key.
   - The password is typically valid for 30 seconds.
   - The same algorithm is used in apps like Google Authenticator and Authy to generate these passwords.
2. **Secret Generation**:
   - Speakeasy can generate a secret key that can be shared between the server and the client. The client will use this key to generate time-sensitive codes.
3. **QR Code**:

   - Speakeasy can be paired with a QR code library to make the user experience smoother. The user scans the QR code to add their account to an authenticator app.

4. **Code Verification**:
   - Once the secret is shared and the user is set up, they will generate a code on their authenticator app. This code is then verified by the server.

---

### **Setting Up Speakeasy Middleware in a Node.js Application**

The middleware can be set up in the Express.js framework to handle tasks such as user registration, 2FA setup, and verification of the TOTP code entered by users.

#### **1. Install Speakeasy and QR Code Libraries**

You need to install `speakeasy` for generating and verifying the TOTP codes, and `qrcode` for generating QR codes.

```bash
npm install speakeasy qrcode
```

#### **2. Middleware for Generating the Secret and QR Code**

When a user enables 2FA, you generate a secret and display a QR code that the user can scan using an authenticator app.

```javascript
const speakeasy = require("speakeasy");
const qrcode = require("qrcode");

function generate2FASecret(req, res, next) {
  try {
    // Step 1: Generate a unique secret for the user
    const secret = speakeasy.generateSecret({
      length: 20,
      name: "YourAppName", // Name of the application, visible to users in their 2FA app
      issuer: "YourAppIssuer", // For example, your app's domain
    });

    // Step 2: Generate a QR code for user to scan
    qrcode.toDataURL(secret.otpauth_url, (err, data_url) => {
      if (err) {
        return res.status(500).send({ message: "Error generating QR code" });
      }

      // You would normally store the secret in the database against the user
      // Example: User model could have a field `2faSecret`

      res.json({
        message: "2FA setup initiated successfully.",
        qrCodeUrl: data_url, // This URL can be embedded in a page for the user to scan
        secret: secret.base32, // The base32 secret should be saved securely, never exposed in plaintext
      });
    });
  } catch (error) {
    return res.status(500).send({ message: "Internal server error." });
  }
}
```

- **Explanation**:

  - **`speakeasy.generateSecret()`** generates a secret key for the user to use in their authenticator app.
  - **`qrcode.toDataURL()`** creates a QR code image that encodes the URL containing the secret. The user will scan this QR code to link their authenticator app with your service.

- **Security Considerations**:
  - **Secret Storage**: Store the `secret.base32` securely, such as in a database, as it is used to verify the TOTP codes.
  - Never expose the secret directly to the client or log it in production environments.

---

#### **3. Middleware for Verifying the TOTP Code**

After the user sets up 2FA, they will need to input the time-based code generated by their authenticator app. You need to verify that this code is correct.

```javascript
function verify2FACode(req, res, next) {
  const { userId, token } = req.body; // The token is the TOTP code the user enters
  const user = getUserFromDatabase(userId); // This is a mock function, you should get the user from your DB

  if (!user || !user.twoFactorSecret) {
    return res
      .status(400)
      .send({ message: "User not found or 2FA not enabled" });
  }

  try {
    // Step 1: Verify the TOTP code using the stored secret
    const isVerified = speakeasy.totp.verify({
      secret: user.twoFactorSecret, // The user's stored secret key
      encoding: "base32", // Encoding type of the secret
      token: token, // The token entered by the user
      window: 6, // Tolerance window of time (6 means 3 steps before and after the time)
    });

    // Step 2: Send response based on verification result
    if (isVerified) {
      res.send({ message: "2FA Code verified successfully." });
    } else {
      res.status(400).send({ message: "Invalid 2FA Code." });
    }
  } catch (error) {
    res.status(500).send({ message: "Internal server error." });
  }
}
```

- **Explanation**:
  - **`speakeasy.totp.verify()`** is used to verify the TOTP entered by the user against the stored secret key.
  - If the token is valid (i.e., matches the expected one based on the shared secret), the user is authenticated.
  - The `window` parameter allows some leniency in time for the code to be valid (for example, 3 steps before and after the expected time).

---

#### **4. Middleware for Enabling/Disabling 2FA**

When a user enables or disables 2FA, you need middleware to handle these actions securely.

```javascript
// Enable 2FA for the user
async function enable2FA(req, res) {
  const userId = req.body.userId;
  const secret = req.body.secret; // The secret the user provides, generated earlier

  // Save the secret to the user's database record (never expose it)
  const user = await User.findById(userId);
  user.twoFactorSecret = secret;
  await user.save();

  res.json({ message: "2FA has been successfully enabled." });
}

// Disable 2FA for the user
async function disable2FA(req, res) {
  const userId = req.body.userId;

  // Remove the secret from the database
  const user = await User.findById(userId);
  user.twoFactorSecret = null;
  await user.save();

  res.json({ message: "2FA has been successfully disabled." });
}
```

- **Explanation**:
  - These functions allow enabling and disabling of 2FA for users. When disabling 2FA, the `twoFactorSecret` is deleted to ensure no further codes can be generated.

---

### **Putting It All Together: Full 2FA Workflow in Express**

```javascript
const express = require("express");
const speakeasy = require("speakeasy");
const qrcode = require("qrcode");
const bodyParser = require("body-parser");

const app = express();
app.use(bodyParser.json());

app.post("/generate-2fa", generate2FASecret);
app.post("/verify-2fa", verify2FACode);
app.post("/enable-2fa", enable2FA);
app.post("/disable-2fa", disable2FA);

// Add other routes and your app logic...

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

---

### **Production-Level Considerations**

1. **Security**:

   - Always encrypt the TOTP secret (`base32` string) when storing it in the database. You should never store it in plaintext.
   - Use HTTPS for all communications to protect secrets and codes from being intercepted.

2. **Rate Limiting**:

   - Implement rate-limiting for the TOTP verification route to protect against brute-force attacks.

3. **Backup Codes**:

   - Provide users with a set of backup codes when they enable 2FA. These codes can be used if they lose access to their authenticator app.

4. **Database Schema**:
   - Your `User` model should have a `twoFactorSecret` field to store the TOTP secret securely. Consider encrypting it in the database.

---

### **Conclusion**

Using Speakeasy as middleware in a production-level Node.js application allows for secure and scalable implementation of two-factor authentication (2FA). By integrating TOTP-based 2FA, you can significantly improve the security of your application by ensuring that users must have both their password and a time-sensitive code generated on their mobile device to access sensitive resources.
